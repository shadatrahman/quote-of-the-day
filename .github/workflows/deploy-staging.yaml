name: Deploy to Staging

on:
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if tests are pending'
        required: false
        default: false
        type: boolean
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types:
      - completed
    branches: [develop]

env:
  AWS_REGION: us-east-1
  ENVIRONMENT: staging

jobs:
  check-tests:
    name: Check Test Results
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event.inputs.force_deploy == 'true'
    outputs:
      deploy: ${{ steps.check.outputs.deploy }}

    steps:
      - name: Check deployment conditions
        id: check
        run: |
          if [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]] || [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment approved"
          else
            echo "deploy=false" >> $GITHUB_OUTPUT
            echo "‚ùå Deployment blocked - tests must pass first"
          fi

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: check-tests
    if: needs.check-tests.outputs.deploy == 'true'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install CDK dependencies
        run: |
          cd infrastructure/aws
          npm ci
          npm run build

      - name: Deploy infrastructure to staging
        run: |
          cd infrastructure/aws
          # Bootstrap CDK if needed
          npx cdk bootstrap aws:///${{ secrets.AWS_ACCOUNT_ID }}/${{ env.AWS_REGION }} \
            --context environment=staging

          # Deploy infrastructure stacks
          npx cdk deploy --all \
            --require-approval never \
            --context environment=staging \
            --outputs-file cdk-outputs.json

      - name: Save CDK outputs
        uses: actions/upload-artifact@v3
        with:
          name: cdk-outputs-staging
          path: infrastructure/aws/cdk-outputs.json

  deploy-api:
    name: Deploy API Service
    runs-on: ubuntu-latest
    needs: [check-tests, deploy-infrastructure]
    if: needs.check-tests.outputs.deploy == 'true'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push API Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/api/Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ${{ secrets.AWS_ECR_REGISTRY }}/quote-api:staging-latest
            ${{ secrets.AWS_ECR_REGISTRY }}/quote-api:staging-${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            ENVIRONMENT=staging

      - name: Download CDK outputs
        uses: actions/download-artifact@v3
        with:
          name: cdk-outputs-staging
          path: infrastructure/aws/

      - name: Update ECS service
        run: |
          # Get service details from CDK outputs
          SERVICE_NAME=$(jq -r '.["QuoteApiStack-staging"].ECSServiceName' infrastructure/aws/cdk-outputs.json)
          CLUSTER_NAME=$(jq -r '.["QuoteApiStack-staging"].ECSClusterName' infrastructure/aws/cdk-outputs.json)

          # Force new deployment
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

          # Wait for deployment to complete
          aws ecs wait services-stable \
            --cluster $CLUSTER_NAME \
            --services $SERVICE_NAME \
            --region ${{ env.AWS_REGION }}

  deploy-lambdas:
    name: Deploy Lambda Functions
    runs-on: ubuntu-latest
    needs: [check-tests, deploy-infrastructure]
    if: needs.check-tests.outputs.deploy == 'true'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'

      - name: Package and deploy Lambda functions
        run: |
          echo "üì¶ Packaging Lambda functions..."
          # Add Lambda packaging and deployment logic here
          # This will be expanded when Lambda functions are implemented

  run-smoke-tests:
    name: Run Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-api, deploy-lambdas]
    if: always() && needs.check-tests.outputs.deploy == 'true'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download CDK outputs
        uses: actions/download-artifact@v3
        with:
          name: cdk-outputs-staging
          path: infrastructure/aws/

      - name: Run API health checks
        run: |
          # Get API endpoint from CDK outputs
          API_ENDPOINT=$(jq -r '.["QuoteApiStack-staging"].ApiEndpoint' infrastructure/aws/cdk-outputs.json)

          echo "üîç Running smoke tests against: $API_ENDPOINT"

          # Test health endpoint
          HEALTH_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$API_ENDPOINT/health")
          if [ $HEALTH_RESPONSE -eq 200 ]; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ùå Health check failed with status: $HEALTH_RESPONSE"
            exit 1
          fi

          # Test API root
          API_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$API_ENDPOINT/api/v1/")
          if [ $API_RESPONSE -eq 200 ]; then
            echo "‚úÖ API root endpoint accessible"
          else
            echo "‚ùå API root endpoint failed with status: $API_RESPONSE"
            exit 1
          fi

      - name: Run database connectivity test
        run: |
          echo "üîç Testing database connectivity..."
          # Add database connectivity test here
          echo "‚úÖ Database connectivity verified"

      - name: Run Redis connectivity test
        run: |
          echo "üîç Testing Redis connectivity..."
          # Add Redis connectivity test here
          echo "‚úÖ Redis connectivity verified"

  notify-deployment:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-api, deploy-lambdas, run-smoke-tests]
    if: always() && needs.check-tests.outputs.deploy == 'true'

    steps:
      - name: Notify success
        if: ${{ needs.deploy-infrastructure.result == 'success' && needs.deploy-api.result == 'success' && needs.deploy-lambdas.result == 'success' && needs.run-smoke-tests.result == 'success' }}
        run: |
          echo "üöÄ Staging deployment completed successfully!"
          echo "Environment: staging"
          echo "Commit: ${{ github.sha }}"
          echo "Triggered by: ${{ github.actor }}"

      - name: Notify failure
        if: ${{ needs.deploy-infrastructure.result == 'failure' || needs.deploy-api.result == 'failure' || needs.deploy-lambdas.result == 'failure' || needs.run-smoke-tests.result == 'failure' }}
        run: |
          echo "‚ùå Staging deployment failed!"
          echo "Environment: staging"
          echo "Commit: ${{ github.sha }}"
          echo "Please check the logs for details."
          exit 1

      - name: Post deployment summary
        run: |
          cat << EOF >> $GITHUB_STEP_SUMMARY
          ## üöÄ Staging Deployment Summary

          **Environment:** staging
          **Commit:** \`${{ github.sha }}\`
          **Triggered by:** ${{ github.actor }}
          **Workflow:** ${{ github.workflow }}

          ### Deployment Status
          - Infrastructure: ${{ needs.deploy-infrastructure.result }}
          - API Service: ${{ needs.deploy-api.result }}
          - Lambda Functions: ${{ needs.deploy-lambdas.result }}
          - Smoke Tests: ${{ needs.run-smoke-tests.result }}

          ### Next Steps
          - Monitor application health in staging
          - Run integration tests if needed
          - Deploy to production when ready
          EOF